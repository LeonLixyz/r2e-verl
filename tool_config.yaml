tools:
  - class_name: "verl.tools.custom_tools.ViewFileTool"
    config: 
      type: native
    tool_schema:
      type: "function"
      function:
        name: "view_file"
        description: "Tool for viewing/exploring the contents of existing files\n* If `path` is a file, `view` displays the result of applying `cat -n`.\n* If `path` is a directory, `view` lists non-hidden files and directories up to 2 levels deep\n* If the output is too long, it will be truncated and marked as such."
        parameters:
          type: "object"
          properties:
            path:
              type: "string"
              description: "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`."
            view_range:
              type: "array"
              description: "Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file."
              items:
                type: "integer"
          required: ["path"]

  - class_name: "verl.tools.custom_tools.EditFileTool"
    config: 
      type: native
    tool_schema:
      type: "function"
      function:
        name: "edit_file"
        description: "Use this tool to propose an edit to an existing file or create a new file.\n\nThis will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.\nWhen writing the edit, you should specify each edit in sequence, with the special comment `// ... existing code ...` to represent unchanged code in between edited lines.\n\nFor example:\n\n```\n// ... existing code ...\nFIRST_EDIT\n// ... existing code ...\nSECOND_EDIT\n// ... existing code ...\nTHIRD_EDIT\n// ... existing code ...\n```\n\nYou should still bias towards repeating as few lines of the original file as possible to convey the change.\nBut, each edit should contain sufficient context of unchanged lines around the code you're editing to resolve ambiguity.\nDO NOT omit spans of pre-existing code (or comments) without using the `// ... existing code ...` comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.\nMake sure it is clear what the edit should be, and where it should be applied.\nTo create a new file, simply specify the content of the file in the `code_edit` field.\n\nYou should specify the following arguments before the others: [target_file]"
        parameters:
          type: "object"
          properties:
            path:
              type: "string"
              description: "The target file to modify. Always specify the target file as the first argument. You must use an absolute path."
            instructions:
              type: "string"
              description: "A single sentence instruction describing what you are going to do for the sketched edit. This is used to assist the less intelligent model in applying the edit. Please use the first person to describe what you are going to do. Dont repeat what you have said previously in normal messages. And use it to disambiguate uncertainty in the edit."
            code_edit:
              type: "string"
              description: "Specify ONLY the precise lines of code that you wish to edit. **NEVER specify or write out unchanged code**. Instead, represent all unchanged code using the comment of the language you're editing in - example: `// ... existing code ...`"
          required: ["path", "instructions", "code_edit"]

  - class_name: "verl.tools.custom_tools.DeleteFilesTool"
    config: 
      type: native
    tool_schema:
      type: "function"
      function:
        name: "delete_files"
        description: "Deletes multiple files or directories at the specified paths. Each operation will fail gracefully if:\n* The file doesn't exist\n* The file cannot be deleted."
        parameters:
          type: "object"
          properties:
            target_file_paths:
              description: "Array of file or directory paths to delete"
              type: "array"
              items:
                type: "string"
          required: ["target_file_paths"]

  - class_name: "verl.tools.custom_tools.BashTool"
    config: 
      type: native
    tool_schema:
      type: "function"
      function:
        name: "bash"
        description: "Run commands in a bash shell\n* When invoking this tool, the contents of the \"command\" parameter does NOT need to be XML-escaped.\n* You have access to a mirror of common linux and python packages via apt and pip.\n* State is persistent across command calls and discussions with the user.\n* To inspect a particular line range of a file, e.g. lines 10-25, try 'sed -n 10,25p /path/to/the/file'.\n* Please avoid commands that may produce a very large amount of output.\n* Please run long lived commands in the background, e.g. 'sleep 10 &' or start a server in the background."
        parameters:
          type: "object"
          properties:
            command:
              type: "string"
              description: "The bash command to run. Required unless the tool is being restarted."
            restart:
              type: "boolean"
              description: "Specifying true will restart this tool. Otherwise, leave this unspecified."
          required: ["command"]

  # - class_name: "verl.tools.custom_tools.GrepSearchTool"
  #   config: 
  #     type: native
  #   tool_schema:
  #     type: "function"
  #     function:
  #       name: "grep_search"
  #       description: "Fast text-based regex search that finds exact pattern matches within files or directories, utilizing the ripgrep command for efficient searching. Results will be formatted in the style of ripgrep and can be configured to include line numbers and content. Use the include or exclude patterns to filter the search scope by file type or specific paths. This is best for finding exact text matches or regex patterns. More precise than semantic search for finding specific strings or patterns. This is preferred over semantic search when we know the exact symbol/function name/etc. to search in some set of directories/file types."
  #       parameters:
  #         type: "object"
  #         properties:
  #           query:
  #             type: "string"
  #             description: "The regex pattern to search for"
  #           case_sensitive:
  #             type: "boolean"
  #             description: "Whether the search should be case sensitive"
  #           exclude_pattern:
  #             type: "string"
  #             description: "Glob pattern for files to exclude"
  #           include_pattern:
  #             type: "string"
  #             description: "Glob pattern for files to include (e.g. '.ts' for TypeScript files)"
  #         required: ["query"]
  #         additionalProperties: false

  # - class_name: "verl.tools.custom_tools.UndoTool"
  #   config: 
  #     type: native
  #   tool_schema:
  #     type: "function"
  #     function:
  #       name: "undo"
  #       description: "Undoes the most recent change to tracked files in the workspace.

  #         * This acts like `git revert`. Calling it consecutively will undo the first undo.
  #         * This will not undo any changes to files outside of the workspace.
  #         * This may not undo all side effects of running other tools.
  #         * The undo may apply to changes from a tool call in the distant past (if the most recent tool calls did not result in any changes to tracked files)."
  #       parameters:
  #         type: "object"
  #         properties: {}
  #         required: []

  # - class_name: "verl.tools.custom_tools.SearchAndReplaceTool"
  #   config: 
  #     type: native
  #   tool_schema:
  #     type: "function"
  #     function:
  #       name: "search_and_replace"
  #       description: "This is a tool for editing files. For moving or renaming files, you should generally use the Bash tool with the 'mv' command instead.

  #         Before using this tool:
  #         1. Use the view_file tool to understand the file's contents and context
  #         2. Verify the directory path is correct (only applicable when creating new files)

  #         The tool will replace ONE occurrence of old_string with new_string in the specified file.
  #         CRITICAL REQUIREMENTS FOR USING THIS TOOL:
  #         1. UNIQUENESS: The old_string MUST uniquely identify the specific instance you want to change. This means:
  #           - Include AT LEAST 3-5 lines of context BEFORE the change point
  #           - Include AT LEAST 3-5 lines of context AFTER the change point
  #           - Include all whitespace, indentation, and surrounding code exactly as it appears in the file
  #         2. SINGLE INSTANCE: This tool can only change ONE instance at a time. If you need to change multiple instances:
  #           - Make separate calls to this tool for each instance
  #           - Each call must uniquely identify its specific instance using extensive context
  #         3. VERIFICATION: Before using this tool:
  #           - Check how many instances of the target text exist in the file
  #           - If multiple instances exist, gather enough context to uniquely identify each one
  #           - Plan separate tool calls for each instance

  #         WARNING: If you do not follow these requirements:
  #           - The tool will fail if old_string matches multiple locations
  #           - The tool will fail if old_string doesn't match exactly (including whitespace)
  #           - You may change the wrong instance if you don't include enough context
  #         When making edits:
  #           - Ensure the edit results in idiomatic, correct code
  #           - Do not leave the code in a broken state
  #           - Always use absolute file paths (starting with /)
  #         If you want to create a new file, use:
  #           - A new file path, including dir name if needed
  #           - An empty old_string
  #           - The new file's contents as new_string
  #         Remember: when making multiple file edits in a row to the same file, you should prefer to send all edits in a single message with multiple calls to this tool, rather than multiple messages with a single call each."
  #       parameters:
  #         type: "object"
  #         properties:
  #           path:
  #             type: "string"
  #             description: "The absolute path to the file to modify (must be absolute, not relative)"
  #           old_string:
  #             type: "string"
  #             description: "The text to replace (must be unique within the file, and must match the file contents exactly, including all whitespace and indentation)"
  #           new_string:
  #             type: "string"
  #             description: "The edited text to replace the old_string"
  #         required: ["path", "old_string", "new_string"]